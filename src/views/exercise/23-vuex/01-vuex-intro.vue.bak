<comments>
  由于模块A使用默认的namespaced:false,所以除了其state以外,mutation getter action 均属于全局
  划分子命名空间的版本,见02-vuex-ns.vue
</comments>

<template>
  <accordion-hull header="Vuex介绍">
    <accordion-item caption="各状态监视">
      <ul>
        <li>
          <span>模块A(firstModule)状态监视:</span>
          <span>count: {{ $store.state.ModA?.count }}</span>
          <span>utterance: {{ $store.state.ModA?.utterance }}</span>
          <span>待办事项监视todos:</span>
          <ul>
            <li v-for="(todo, i) in $store.state.ModA?.todos" :key="i">
              <span>{{ i + 1 }}.{{ todo.description }}</span>
            </li>
          </ul>
        </li>
      </ul>
    </accordion-item>
    <accordion-item
      caption="状态属性转换为计算属性,以count为例.注意,
    计算属性中的this,在运行时可正确指向,智能感知有时提示错误,所以已经将this换成计算属性的内部参数vm"
    >
      <ul>
        <li>
          <span>this.$store.state.ModA.count:{{ localCount1 }}</span>
          <span>this.firstState.count:{{ localCount2 }}</span>
        </li>
      </ul>
    </accordion-item>
    <accordion-item
      caption="使用mapState,生成计算属性.注意查看源码,测试正常考虑注释掉,因为编译老报错.在第370行左右"
    >
      <ul>
        <li>
          <span
            >localCount3: (state) => state.ModA.count,方式:{{
              localCount3
            }}</span
          >
          <span
            >localUtterance3: (state) => state.ModA.utterance方式:{{
              localUtterance3
            }}</span
          >
          <span>localCount4:'first.count'方式:{{ localCount4 || "无效" }}</span>
          <span>localCount5:"count"方式:{{ localCount5 || "无效" }}</span>
          <span>与本地数据合并,必须使用常规函数:{{ totalCount }}</span>
        </li>
      </ul>
    </accordion-item>
    <accordion-item
      caption="getter的常规使用,getter被认为是全局的,通过store.getters属性访问"
    >
      <ul>
        <li>
          <span>$store.getters.doneTodos:</span>
          <span>{{ $store.getters.doneTodos }}</span>
        </li>
        <li>
          <span>$store.getters.doneTodosCount:</span>
          <span>{{ $store.getters.doneTodosCount }}</span>
        </li>
        <li>
          <span>带参数的getter: $store.getters.getTodoById(2):</span>
          <span>{{ $store.getters.getTodoById(2) }}</span>
        </li>
      </ul>
    </accordion-item>
    <accordion-item
      caption="getter也可以转化为计算属性访问,为的是不用写这一大串"
    >
      <ul>
        <li>
          <span>getter属性doneTodosCount转为计算属性:</span>
          <span>{{ localDoneTodosCount1 }}</span>
        </li>
        <li>
          <span>getter属性doneTodos转为计算属性:</span>
          <span>{{ localDoneTodos1 }}</span>
        </li>
        <li>
          <span>getter之getTodoById(2)带带参数属性:</span>
          <span>{{ localGetTodoById1(2) }}</span>
        </li>
      </ul>
    </accordion-item>
    <accordion-item
      caption="mapGetters辅助函数,使用数组风格映射getter为局部计算属性"
    >
      <ul>
        <li>
          <span>映射得到doneTodosCount的同名计算属性:</span>
          <span>{{ doneTodosCount }}</span>
        </li>
        <li>
          <span>映射得到doneTodos的同名计算属性:</span>
          <span>{{ doneTodos }}</span>
        </li>
        <li>
          <span>映射得到getTodoById(id)的同名计算属性:</span>
          <span>{{ getTodoById(2) }}</span>
        </li>
      </ul>
    </accordion-item>
    <accordion-item
      caption="mapGetters辅助函数,使用对象风格映射getter为局部计算属性"
    >
      <ul>
        <li>
          <span>映射得到localDoneTodosCount2异名计算属性:</span>
          <span>{{ doneTodosCount }}</span>
        </li>
        <li>
          <span>映射得到localDoneTodos2的异名计算属性:</span>
          <span>{{ doneTodos }}</span>
        </li>
        <li>
          <span>映射得到localGetTodoById2(id)的异名计算属性:</span>
          <span>{{ getTodoById(2) }}</span>
        </li>
      </ul>
    </accordion-item>

    <accordion-item caption="使用store提交mutation事件">
      <ul>
        <li>
          <input
            type="button"
            value="this.$store.commit(Guoshi.Consts.INCREMENT)"
            @click="demo1"
          />
        </li>
        <li>
          <input
            type="button"
            value="this.$store.commit(REVERSE)"
            @click="demo2"
          />
        </li>
        <li>
          <input
            type="button"
            value="this.$store.commit(Guoshi.Consts.ADD_COUNT, 15)载荷风格,载荷为简单number类型"
            @click="demo3"
          />
        </li>
        <li>
          <input
            type="button"
            value="this.$store.commit(Guoshi.Consts.ADD_TODO,{...})载荷风格,载荷为Todo对象类型"
            @click="demo4"
          />
        </li>
        <li>
          <input
            type="button"
            value="对象风格,载荷为该对象的一个属性,本例仅包含count的增量"
            @click="demo5"
          />
        </li>
        <li>
          <input
            type="button"
            value="对象风格,载荷为该对象的一个属性,本例仅包含新增的todo"
            @click="demo6"
          />
        </li>
        <li>
          <input
            type="button"
            value="对象风格,载荷为该对象的一个属性,本例包含上述两者"
            @click="demo7"
          />
        </li>
      </ul>
    </accordion-item>
    <accordion-item
      caption="利用mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用"
    >
      <ul>
        <li>
          <input
            type="button"
            value="使用数组形式映射到本地"
            @click="increment"
          />
        </li>
        <li>
          <input
            type="button"
            value="使用对象形式映射到本地"
            @click="mutAddCount"
          />
        </li>
        <li>
          <input
            type="button"
            value="使用addTodo"
            @click="
              addTodo({
                id: 199,
                description: 'welcome',
                done: false,
              })
            "
          />
        </li>
        <li>
          <input
            type="button"
            value="使用Guoshi.Consts.ADD_COUNT"
            @click="Guoshi.Consts.ADD_COUNT(2819)"
          />
        </li>
        <li>
          <input
            type="button"
            value="使用Guoshi.Consts.ADD_USING_OBJECT_STYLE"
            @click="
              [Guoshi.Consts.ADD_USING_OBJECT_STYLE({
                type: Guoshi.Consts.ADD_USING_OBJECT_STYLE,
                amount: 38,
                todo: {
                  id: 199,
                  description: 'hi,you win',
                  done: true,
                },
              })"
          />
        </li>
      </ul>
    </accordion-item>
    <accordion-item caption="action的常规用法:$store.dispatch">
      <ul>
        <li>
          <input
            type="button"
            value="以载荷方式加10"
            @click="$store.dispatch('addCountAsync', 10)"
          />
        </li>
        <li>
          <input
            type="button"
            value="以对象方式加25"
            @click="
              $store.dispatch({
                type: 'addUsingObjectStyleAsync',
                amount: 25,
              })
            "
          />
        </li>
      </ul>
    </accordion-item>
    <accordion-item caption="action的映射用法,映射成组件methods之一">
      <ul>
        <li>
          <span> this.reverse()映射为this.$store.dispatch('reverse') </span>
          <input type="button" value="逆转字串" @click="reverse" />
        </li>
        <li>
          <span
            >addUsingObjectStyleAsync({...})到$store.dispatch({type='add...',...}),对象风格</span
          >
          <input
            type="button"
            value="递增17"
            @click="
              addUsingObjectStyleAsync({
                type: 'addUsingObjectStyleAsync',
                amount: 17,
              })
            "
          />
        </li>
        <li>
          <span
            >this.act_add_count映射为$store.dispatch('addCountAsync',amount:number).载荷风格</span
          >
          <input type="button" value="递增19" @click="actAddCountAsync(19)" />
        </li>
      </ul>
    </accordion-item>
    <accordion-item caption="action的异步特征及使用,与await组合等">
      <ul>
        <li>
          <span>
            action:Guoshi.Consts.INCREMENTAsync,无promise返回,仅仅以延时模拟异步递增count
            实验结果:dispatch方法本身虽然返回promise,但由于此action并未做过Promise雕琢.
            所以该promise的返回值未undefined.
          </span>
          <input type="button" value="only dispatch" @click="demo8" />
          <input type="button" value="dispatch and then" @click="demo9" />
          <input type="button" value="await dispatch" @click="demo10" />
        </li>
        <li>
          <span>
            让action返回Promise,store.dispatch可以处理该Promise，
            并且store.dispatch仍旧返回 Promise：
          </span>
          <input type="button" value="dispatch & then" @click="demo11" />
          <input type="button" value="await dispatch" @click="demo12" />
          <input type="button" value="nested commit dispatch" @click="demo13" />
        </li>
      </ul>
    </accordion-item>
    <accordion-item caption="store之严格模式下的表单绑定问题">
      <ul>
        <li>
          <span
            >使用v-model的双向绑定到state的对象之属性,
            在用户输入时,因为v-因为v-model试图修改
            该属性(Guoshi.Types.Student.name), 由于这个修改不是在 mutation
            函数中执行的, 这里会抛出一个错误。 当然, 非严格模式则无此问题</span
          >
          <input v-model="firstState.utterance" />
        </li>
        <li>
          <span
            >解决方案1, 较繁琐: 绑定value,侦听input事件,
            在回调中调用mutation</span
          >
          >
          <input :value="firstState.utterance" @input="updateUtt" />
        </li>
        <li>
          <span>解决方案2, 与上基本一致, 但使用的是change事件</span>
          >
          <input :value="firstState.utterance" @change="updateUtt" />
        </li>
        <li>
          <span>使用带有setter的双向绑定计算属性</span>
          <input v-model="cmpUtt" />
        </li>
      </ul>
    </accordion-item>
    <accordion-item caption="useStore的类型参数测试">
      <input type="button" value="start" @click="test_useStore_type_pram" />
    </accordion-item>
  </accordion-hull>
</template>

<script lang="ts">
import { defineComponent, getCurrentInstance, reactive, computed } from "vue";

import {
  useStore, //注释, 改为使用自定义useStore,可以提供类型支持
  mapState,
  mapGetters,
  mapMutations,
  mapActions,
  ModuleTree,
  Module,
  Store,
} from "vuex";
//import {useStore} from '@/store';
import ChatState from "@/views/exercise/25-official-store-example/chat/ts-version/api/ChatState.class";

//这里是组合式和选项式混装一起的用法
export default defineComponent({
  components: {},
  // data() {
  //   //所有的action mutations等均为全局调用
  //   //const store = useStore();
  //   return {
  //     /**
  //      * ModuleA的状态
  //      */
  //     firstState: useStore().state.ModA as Module<Guoshi.Intfs.IVueState, Guoshi.Types.Student>,
  //     ownData: 100,
  //   };
  // },
  setup() {
    //#region  测试原版useStore
    console.clear();
    console.log("useStore():", useStore());
    console.log(
      "useStore<Guoshi.Types.Student>():",
      useStore<Guoshi.Types.Student>()
    );
    console.log(
      "useStore<Guoshi.Intfs.IVueState>()",
      useStore<Guoshi.Intfs.IVueState>()
    );
    console.log(
      "useStore<Guoshi.Types.UserInfo>()",
      useStore<Guoshi.Types.UserInfo>()
    );
    console.log(
      "useStore<Guoshi.Types.Author>()",
      useStore<Guoshi.Types.Author>()
    );
    console.log(
      "s_jschat",
      useStore<{
        currentThreadID: any;
        threads: {};
        messages: {};
      }>()
    );
    console.log("useStore<ChatState>()", useStore<ChatState>());
    console.log(
      "useStore<Guoshi.Types.LoadingState>()",
      useStore<Guoshi.Types.LoadingState>()
    );
    console.log(
      "infact,they are all the same.for example:",
      useStore() == useStore<ChatState>(),
      useStore() ==
        useStore<{
          currentThreadID: any;
          threads: {};
          messages: {};
        }>()
    );
    //#endregion

    //一切为了消除编译时的误判
    //const temp = useStore().state.age;  //number, instead of any

    const firstState = useStore().state.ModA;
    const store = useStore() as Store<Guoshi.Types.Student>;
    return {
      firstState,
      ownData: 100,
      //双向绑定的计算属性
      cmpUtt: computed({
        get() {
          //@ts-ignore
          return firstState.utterance;
        },
        set(value) {
          store.commit(Guoshi.Consts.UPDATE_UTTERANCE, value);
        },
      }),
    };
  },

  computed: {
    //计算属性代理的状态属性
    localCount1() {
      return this.$store.state.ModA?.count;
    },
    localCount2(vm) {
      //console.log("vm 和 this 在计算属性中:", vm == this); //true

      //@ts-ignore  这样就可忽略编译时的误判
      return this.firstState.count;
      //也可以改成下面一句:
      //return vm.firstState.count;
    },

    //将它与局部计算属性混合使用的最简方式
    //注意,下面虽然运行正常,但是仍然编译报错,必须动用 ts-ignore
    ...mapState({
      //@ts-ignore
      localCount3: (state) => state.ModA.count,
      //@ts-ignore
      localUtterance3: (state) => state.ModA.utterance,
      localCount4: "first.count", //error
      localCount5: "count", //error
      totalCount(state: any) {
        return this.ownData + state.ModA.count; //
      },
    }),

    //还可以是数组形式,表示映射的计算属性的名称与 state 的子节点名称相同.
    //但是多模块状态不适用,因为无法确认是那个模块
    // ...mapState(["count", "utterance"]), //ok，使用相同名称

    //使用计算属性代理状态的getter属性
    localDoneTodosCount1() {
      return this.$store.getters.doneTodosCount;
    },
    localDoneTodos1() {
      return this.$store.getters.doneTodos;
    },
    localGetTodoById1() {
      return (id: number) => {
        return this.$store.getters.getTodoById(id);
      };
    },

    //与mapState类似,映射getter为计算属性,
    //有参getter也可以
    ...mapGetters(["doneTodosCount", "doneTodos", "getTodoById"]),
    ...mapGetters({
      localDoneTodosCount2: "doneTodosCount",
      localDoneTodos2: "doneTodosCount",
      localGetTodoById2: "getTodoById",
    }),
  },
  methods: {
    demo1() {
      this.$store.commit("Guoshi.Consts.INCREMENT"); //ok
      //this.$store.state.ModA.count++; // 这样居然也可以，虽然不太文明
      this.$store.commit(Guoshi.Consts.INCREMENT); //ok,但是$store无法智能感知
    },
    demo2() {
      //@ts-ignore
      //this.firstState.commit("reverse"); //error
      this.$store.commit(REVERSE); //ok,但是$store无法智能感知
    },
    demo3() {
      this.$store.commit(Guoshi.Consts.ADD_COUNT, 15);
    },
    demo4() {
      this.$store.commit(Guoshi.Consts.ADD_TODO, {
        id: 88,
        description: "hello,world",
        done: true,
      });
    },
    demo5() {
      this.$store.commit({
        type: Guoshi.Consts.ADD_USING_OBJECT_STYLE,
        amount: 11,
      });
    },
    demo6() {
      this.$store.commit({
        type: Guoshi.Consts.ADD_USING_OBJECT_STYLE,
        todo: {
          id: 99,
          description: "do something suable",
          done: true,
        },
      });
    },
    demo7() {
      this.$store.commit({
        type: Guoshi.Consts.ADD_USING_OBJECT_STYLE,
        amount: 38,
        todo: {
          id: 199,
          description: "hi,you gay",
          done: true,
        },
      });
    },

    //组合action测试:
    demo8() {
      const t = this.$store.dispatch("Guoshi.Consts.INCREMENTAsync");
      console.log("dispatch over", t);
    },
    demo9() {
      this.$store.dispatch("Guoshi.Consts.INCREMENTAsync").then((data: any) => {
        console.log("dipatch ,then over", data);
      });
    },
    async demo10() {
      const t = await this.$store.dispatch("Guoshi.Consts.INCREMENTAsync");
      console.log("await dipatch,and over", t);
    },
    demo11() {
      const t = this.$store.dispatch("actionA").then((data: any) => {
        console.log("resolve data is ", data);
      });
      console.log("dispatch is ", t);
    },
    async demo12() {
      const resp = await this.$store.dispatch("actionA");
      console.log("await dispatch actionA finish.resp is ", resp);
    },
    async demo13() {
      const resp = await this.$store.dispatch("actionB");
      console.log("await dispatch actionB finish,resp is ", resp);
    },

    //类似地,使用数组参数形式映射Mutation到本地
    ...mapMutations([Guoshi.Consts.INCREMENT, Guoshi.Consts.ADD_TODO]),
    //使用对象参数形式
    ...mapMutations({
      //this.Guoshi.Consts.ADD_COUNT与store.commit('addCount')映射
      mutAddCount: Guoshi.Consts.ADD_COUNT,
      //this.Guoshi.Consts.ADD_USING_OBJECT_STYLE与 store.commit('addUsingObjectStyle')
      mutAddUsingObjectStyle: Guoshi.Consts.ADD_USING_OBJECT_STYLE,
    }),

    //类似,映射Action到本地,注意不要重名
    ...mapActions([
      //将 `this.reverse()` 映射为 `this.$store.dispatch('reverse')`
      Guoshi.Consts.REVERSE,
      //对象风格的载荷映射:this.addUsingObjectStyleAsync({...})到$store.dispatch({type="add...",...});
      "addUsingObjectStyleAsync",
    ]),
    ...mapActions({
      //this.act_Guoshi.Consts.ADD_COUNT映射为$store.dispatch('addCountAsync',amount:number).
      actAddCountAsync: "addCountAsync",
    }),

    ///////////////严格模式下, 表单绑定state属性的处理
    updateUtt(evt: Event) {
      //@ts-ignore
      this.$store.commit(Guoshi.Consts.UPDATE_UTTERANCE, evt.target.value);
    },
    ////////////useStore的类型参数测试
    test_useStore_type_pram() {
      //useStore 由于调用inject()的缘故,只能在setup()或函数组件中使用
      console.clear();
      console.log("useStore():", useStore());
      console.log(
        "useStore<Guoshi.Types.Student>():",
        useStore<Guoshi.Types.Student>()
      );
      console.log(
        "useStore<Guoshi.Intfs.IVueState>()",
        useStore<Guoshi.Intfs.IVueState>()
      );
      console.log(
        "useStore<Guoshi.Types.UserInfo>()",
        useStore<Guoshi.Types.UserInfo>()
      );
      console.log(
        "useStore<Guoshi.Types.Author>()",
        useStore<Guoshi.Types.Author>()
      );
      console.log(
        "s_jschat",
        useStore<{
          currentThreadID: any;
          threads: {};
          messages: {};
        }>()
      );
      console.log("useStore<ChatState>()", useStore<ChatState>());
      console.log(
        "useStore<Guoshi.Types.LoadingState>()",
        useStore<Guoshi.Types.LoadingState>()
      );
    },
  },
});
</script>
