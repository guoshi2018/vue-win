<template>
  <div class="test loc">
    <h2>Hi,this is a component with inner view</h2>
    <ul>
      <li>
        <span>$route.fullPath == {{ $route.fullPath }}</span>
      </li>
      <li>
        <span>$route.query == {{ $route.query }}</span>
      </li>
      <li>
        <span>$route.params == {{ $route.params }}</span>
      </li>
      <li>
        <span>$route.redirected from : {{ $route.redirectedFrom }}</span>
      </li>
    </ul>
  </div>
  <!---->
  <div>
    <router-view></router-view>
  </div>
</template>

<script lang="ts">
import { defineComponent } from "vue";
//注意没有 onBeforeRouteEnter
import { onBeforeRouteLeave, onBeforeRouteUpdate } from "vue-router";
import { print } from "@/common/mixins/func";
const debug = false;

export default defineComponent({
  //可以在路由组件内直接定义路由导航守卫(传递给路由配置的)
  beforeRouteEnter(to, from, next) {
    // 在渲染该组件的对应路由被验证前调用
    // 不能获取组件实例 `this` ！
    // 因为当守卫执行时，组件实例还没被创建！
    print(debug,"inner-view.vue component beforeRouteEnter.");

    //不过，你可以通过传一个回调给 next 来访问组件实例。
    //在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数
    //注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫
    //其他两个守卫，this已经可用
    next((vm) => {
      // 通过 `vm` 访问组件实例
      print(debug,"inner-view.vue instance is :", vm);
    });
  },
  beforeRouteUpdate(to, from) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，
    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`
    print(debug,"inner-view.vue component beforeRouteUpdate.");
  },
  beforeRouteLeave(to, from) {
    // 在导航离开渲染该组件的对应路由时调用
    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`
    print(debug,"inner-view.vue component beforeRouteLeave.");

    // 离开守卫 通常用来预防用户在还未保存修改前突然离开。该导航可以通过返回 false 来取消。
    const answer = window.confirm("Do you really want to leave?");
    if (!answer) {
      return false;
    }
  },
  setup() {
    //也可以安插在setup中配置钩子
    // 与 beforeRouteLeave 相同，无法访问 `this`
    onBeforeRouteLeave((to, from) => {
      // const answer = window.confirm(
      //   "Do you really want to leave? you have unsaved changes!"
      // );
      // // 取消导航并停留在同一页面上
      // if (!answer) {
      //   return false;
      // }
      print(debug,"inner-view.vue component setup().onBeforeRouteLeave.");
    });

    // 与 beforeRouteUpdate 相同，无法访问 `this`
    onBeforeRouteUpdate(async (to, from) => {
      print(debug,"inner-view.vue component setup().onBeforeRouteUpdate.");
    });
  },
});
</script>

<style lang="css" scoped>
.loc {
  width: 75%;
  margin: 2px auto;
  background-color: dodgerblue;
}
</style>
